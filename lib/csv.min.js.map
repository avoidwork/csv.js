{"version":3,"sources":["csv.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","global","coerce","value","tmp","undefined","isNaN","Number","REGEX_JSON","test","parse","decode","arg","delimiter","arguments","length","regex","RegExp","rows","trim","split","keys","shift","result","nth","x","i","n","row","replace","push","encode","header","Array","Object","join","map","prepare","cast","REGEX_NL","JSON","e","input","output","toString","REGEX_OBJTYPE","REGEX_QUOTE","REGEX_IE","navigator","ie","userAgent","version","parseInt","key","o","iterate","slice","call","idx","fn","Error","forEach","has","hasOwnProperty","v","k","iface","exports","module","define","amd","csv","window"],"mappings":"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","file":"csv.min.js","sourcesContent":["\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\r\n * Simplify encoding & decoding CSV\r\n *\r\n * @author Jason Mulligan <jason.mulligan@avoidwork.com>\r\n * @copyright 2017\r\n * @license BSD-3-Clause\r\n * @version 1.0.4\r\n */\n(function (global) {\n\t\"use strict\";\n\n\tvar REGEX_IE = /msie|ie/i,\n\t    REGEX_NL = /\\n$/,\n\t    REGEX_OBJTYPE = /\\[object Object\\]/,\n\t    REGEX_JSON = /^[\\[\\{]/,\n\t    REGEX_QUOTE = /^\\s|\\\"|\\n|,|\\s$/,\n\t    navigator = global.navigator,\n\t    ie = navigator ? REGEX_IE.test(navigator.userAgent) : false,\n\t    version = ie ? parseInt(navigator.userAgent.replace(/(.*msie|;.*)/gi, \"\"), 10) : null;\n\n\t/**\r\n  * Returns an Object ( NodeList, etc. ) as an Array\r\n  *\r\n  * @method cast\r\n  * @param  {Object}  obj Object to cast\r\n  * @param  {Boolean} key [Optional] Returns key or value, only applies to Objects without a length property\r\n  * @return {Array}       Object as an Array\r\n  */\n\tvar cast = function () {\n\t\tif (!ie || version > 8) {\n\t\t\treturn function (obj) {\n\t\t\t\tvar key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\t\t\tvar o = [];\n\n\t\t\t\tif (!isNaN(obj.length)) {\n\t\t\t\t\to = Array.prototype.slice.call(obj);\n\t\t\t\t} else {\n\t\t\t\t\tkey ? o = keys(obj) : iterate(obj, function (i) {\n\t\t\t\t\t\treturn o.push(i);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn o;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function (obj) {\n\t\t\t\tvar key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\t\t\tvar o = [];\n\n\t\t\t\tif (!isNaN(obj.length)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\to = Array.prototype.slice.call(obj);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\titerate(obj, function (i, idx) {\n\t\t\t\t\t\t\tif (idx !== \"length\") {\n\t\t\t\t\t\t\t\to.push(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkey ? o = keys(obj) : iterate(obj, function (i) {\n\t\t\t\t\t\treturn o.push(i);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn o;\n\t\t\t};\n\t\t}\n\t}();\n\n\t/**\r\n  * Coerces a String to a Type\r\n  *\r\n  * @method coerce\r\n  * @memberOf utility\r\n  * @param  {String} value String to coerce\r\n  * @return {Mixed}        Primitive version of the String\r\n  */\n\tfunction coerce(value) {\n\t\tvar tmp;\n\n\t\tif (value === null || value === undefined) {\n\t\t\treturn undefined;\n\t\t} else if (value === \"true\") {\n\t\t\treturn true;\n\t\t} else if (value === \"false\") {\n\t\t\treturn false;\n\t\t} else if (value === \"null\") {\n\t\t\treturn null;\n\t\t} else if (value === \"undefined\") {\n\t\t\treturn undefined;\n\t\t} else if (value === \"\") {\n\t\t\treturn value;\n\t\t} else if (!isNaN(tmp = Number(value))) {\n\t\t\treturn tmp;\n\t\t} else if (REGEX_JSON.test(value)) {\n\t\t\treturn parse(value) || value;\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\r\n  * Converts CSV to an Array of Objects\r\n  *\r\n  * @method decode\r\n  * @param  {String} arg       CSV string\r\n  * @param  {String} delimiter [Optional] Delimiter to split columns on, default is \",\"\r\n  * @return {Array}            Array of Objects\r\n  */\n\tfunction decode(arg) {\n\t\tvar delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \",\";\n\n\t\tvar regex = new RegExp(delimiter + \"(?=(?:[^\\\"]|\\\"(?:[^\\\"])[^\\\"]*\\\")*$)\"),\n\t\t    rows = trim(arg).split(\"\\n\"),\n\t\t    keys = rows.shift().split(delimiter),\n\t\t    result = [],\n\t\t    nth = rows.length,\n\t\t    x = keys.length;\n\n\t\tvar i = -1,\n\t\t    n = void 0,\n\t\t    obj = void 0,\n\t\t    row = void 0;\n\n\t\twhile (++i < nth) {\n\t\t\tobj = {};\n\t\t\trow = rows[i].split(regex);\n\n\t\t\tn = -1;\n\t\t\twhile (++n < x) {\n\t\t\t\tobj[keys[n]] = coerce((row[n] || \"\").replace(/^\"|\"$/g, \"\"));\n\t\t\t}\n\n\t\t\tresult.push(obj);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\r\n  * Encodes `arg` as CSV\r\n  *\r\n  * @method encode\r\n  * @param  {String}  arg       Array, Object or JSON String to transform\r\n  * @param  {String}  delimiter [Optional] Character to separate fields\r\n  * @param  {Boolean} header    [Optional] False to not include field names as first row\r\n  * @return {String}            CSV string\r\n  */\n\tfunction encode(arg) {\n\t\tvar delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \",\";\n\t\tvar header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n\t\tvar obj = parse(arg) || arg;\n\t\tvar result = \"\";\n\n\t\tif (obj instanceof Array) {\n\t\t\tif (obj[0] instanceof Object) {\n\t\t\t\tif (header) {\n\t\t\t\t\tresult = keys(obj[0]).join(delimiter) + \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tresult += obj.map(function (i) {\n\t\t\t\t\treturn encode(i, delimiter, false);\n\t\t\t\t}).join(\"\\n\");\n\t\t\t} else {\n\t\t\t\tresult += prepare(obj, delimiter) + \"\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tif (header) {\n\t\t\t\tresult = keys(obj).join(delimiter) + \"\\n\";\n\t\t\t}\n\n\t\t\tresult += cast(obj).map(function (i) {\n\t\t\t\treturn prepare(i, delimiter);\n\t\t\t}).join(delimiter) + \"\\n\";\n\t\t}\n\n\t\treturn result.replace(REGEX_NL, \"\");\n\t}\n\n\t/**\r\n  * Iterates an Object and executes a function against the properties,\r\n  * & can be halted by returning `false` from `fn`\r\n  *\r\n  * @method iterate\r\n  * @param  {Object}   obj Object to iterate\r\n  * @param  {Function} fn  Function to execute against properties\r\n  * @return {Object}       Object\r\n  */\n\tvar iterate = function () {\n\t\tif (typeof Object.keys == \"function\") {\n\t\t\treturn function (obj, fn) {\n\t\t\t\tif (typeof fn != \"function\") {\n\t\t\t\t\tthrow new Error(\"Invalid arguments\");\n\t\t\t\t}\n\n\t\t\t\tObject.keys(obj).forEach(function (i) {\n\t\t\t\t\treturn fn.call(obj, obj[i], i);\n\t\t\t\t});\n\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function (obj, fn) {\n\t\t\t\tvar has = Object.prototype.hasOwnProperty,\n\t\t\t\t    i,\n\t\t\t\t    result;\n\n\t\t\t\tif (typeof fn != \"function\") {\n\t\t\t\t\tthrow new Error(\"Invalid arguments\");\n\t\t\t\t}\n\n\t\t\t\tfor (i in obj) {\n\t\t\t\t\tif (has.call(obj, i)) {\n\t\t\t\t\t\tresult = fn.call(obj, obj[i], i);\n\n\t\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}\n\t}();\n\n\t/**\r\n  * Returns the keys in an \"Associative Array\"\r\n  *\r\n  * @method keys\r\n  * @param  {Mixed} obj Array or Object to extract keys from\r\n  * @return {Array}     Array of the keys\r\n  */\n\tvar keys = function () {\n\t\tif (typeof Object.keys == \"function\") {\n\t\t\treturn function (obj) {\n\t\t\t\treturn Object.keys(obj);\n\t\t\t};\n\t\t} else {\n\t\t\treturn function (obj) {\n\t\t\t\tvar keys = [];\n\n\t\t\t\titerate(obj, function (v, k) {\n\t\t\t\t\treturn keys.push(k);\n\t\t\t\t});\n\n\t\t\t\treturn keys;\n\t\t\t};\n\t\t}\n\t}();\n\n\t/**\r\n  * Parses the argument\r\n  *\r\n  * @method parse\r\n  * @param  {String} arg String to parse\r\n  * @return {Mixed}      Resulting from parsing JSON, or undefined\r\n  */\n\tfunction parse(arg) {\n\t\ttry {\n\t\t\treturn JSON.parse(arg);\n\t\t} catch (e) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\r\n  * Prepares input based on CSV rules\r\n  *\r\n  * @method param\r\n  * @param  {Mixed}  input     Array, Object or String\r\n  * @param  {String} delimiter [Optional] Character to separate fields\r\n  * @return {String}           CSV formatted String\r\n  */\n\tfunction prepare(input, delimiter) {\n\t\tvar output = void 0;\n\n\t\tif (input instanceof Array) {\n\t\t\toutput = \"\\\"\" + input.toString() + \"\\\"\";\n\n\t\t\tif (REGEX_OBJTYPE.test(output)) {\n\t\t\t\toutput = \"\\\"\" + encode(input, delimiter) + \"\\\"\";\n\t\t\t}\n\t\t} else if (input instanceof Object) {\n\t\t\toutput = \"\\\"\" + encode(input, delimiter) + \"\\\"\";\n\t\t} else if (REGEX_QUOTE.test(input)) {\n\t\t\toutput = \"\\\"\" + input.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\";\n\t\t} else {\n\t\t\toutput = input;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\t/**\r\n  * Trims a string\r\n  *\r\n  * @method  trim\r\n  * @param  {String} arg String to trim\r\n  * @return {String}     Trimmed String\r\n  */\n\tfunction trim(arg) {\n\t\treturn arg.replace(/^(\\s+|\\t+)|(\\s+|\\t+|\\n+)$/g, \"\");\n\t}\n\n\t/**\r\n  * Interface\r\n  *\r\n  * @type {Object}\r\n  */\n\tvar iface = {\n\t\tdecode: decode,\n\t\tencode: encode,\n\t\tversion: \"1.0.4\"\n\t};\n\n\t// CommonJS, AMD, script tag\n\tif (typeof exports != \"undefined\") {\n\t\tmodule.exports = iface;\n\t} else if (typeof define == \"function\" && _typeof(define.amd) !== void 0) {\n\t\tdefine(function () {\n\t\t\treturn iface;\n\t\t});\n\t} else {\n\t\tglobal.csv = iface;\n\t}\n})(typeof window !== \"undefined\" ? window : global);\n"]}