{"version":3,"sources":["csv.js"],"names":["JSON","parse","Array","isArray","length","toString","test","includes","Object","stringify","indexOf","charAt","join","map","replace","isNaN","keys","Error","forEach","call","trim","from","push","decode","RegExp","split","shift","encode","version","exports","define","amd","csv","module","window","global"],"mappings":"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","file":"unknown","sourcesContent":["/**\n * Simplify encoding & decoding CSV\n *\n * @author Jason Mulligan <jason.mulligan@avoidwork.com>\n * @copyright 2021\n * @license BSD-3-Clause\n * @link https://github.com/avoidwork/csv.js\n * @version 2.0.1\n */\n(function (global) {\n\t\n\n\tconst REGEX_NL = /(\\n|\\r)$/,\n\t\tREGEX_OBJTYPE = /\\[object Object\\]/,\n\t\tREGEX_JSON = /^[\\[\\{]/;\n\n\tconst keys = (obj, ref) => ref !== void 0 ? ref.map(i => obj[i]) : Object.keys(obj);\n\n\tconst iterate = (obj, fn, keyRef) => {\n\t\tif (typeof fn !== \"function\") {\n\t\t\tthrow new Error(\"Invalid arguments\");\n\t\t}\n\n\t\t(keyRef || Object.keys(obj)).forEach(i => fn.call(obj, obj[i], i));\n\n\t\treturn obj;\n\t};\n\n\tfunction parse (arg) {\n\t\ttry {\n\t\t\treturn JSON.parse(arg);\n\t\t} catch (e) {\n\t\t\treturn arg;\n\t\t}\n\t}\n\n\tconst trim = arg => arg.trim();\n\n\tconst cast = (obj, key = false, ref) => {\n\t\tlet result;\n\n\t\tif (Array.isArray(obj)) {\n\t\t\tresult = Array.from(obj);\n\t\t} else if (key) {\n\t\t\tresult = keys(obj, ref);\n\t\t} else {\n\t\t\tresult = [];\n\t\t\titerate(obj, i => result.push(i), ref);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tfunction prepare (input, delimiter) {\n\t\tlet output;\n\n\t\tif (Array.isArray(input)) {\n\t\t\tif (input.length === 0) {\n\t\t\t\toutput = \"\";\n\t\t\t} else {\n\t\t\t\toutput = input.toString();\n\n\t\t\t\tif (REGEX_OBJTYPE.test(output)) {\n\t\t\t\t\toutput = `\"${encode(input, delimiter)}\"`; // eslint-disable-line no-use-before-define\n\t\t\t\t} else if (output.includes(delimiter)) {\n\t\t\t\t\toutput = `\"${output}\"`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (input instanceof Object) {\n\t\t\toutput = `\"${JSON.stringify(input)}\"`; // eslint-disable-line no-use-before-define\n\t\t} else if (typeof input === \"string\") {\n\t\t\toutput = input.indexOf(delimiter) > -1 && input.charAt(0) !== \"\\\"\" ? `\"${input}\"` : input;\n\t\t} else {\n\t\t\toutput = input;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tfunction encode (arg, delimiter = \",\", header = true, keyRef) {\n\t\tconst obj = parse(arg);\n\t\tlet result = \"\",\n\t\t\tref;\n\n\t\tif (Array.isArray(obj)) {\n\t\t\tif (obj.length > 0) {\n\t\t\t\tif (obj[0] instanceof Object) {\n\t\t\t\t\tif (header) {\n\t\t\t\t\t\tref = keys(obj[0]);\n\t\t\t\t\t\tresult = ref.join(delimiter) + \"\\n\";\n\t\t\t\t\t}\n\n\t\t\t\t\tresult += obj.map(i => encode(i, delimiter, false, ref)).join(\"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tresult += prepare(obj, delimiter) + \"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (header) {\n\t\t\t\tref = keys(obj, keyRef);\n\t\t\t\tresult = ref.join(delimiter) + \"\\n\";\n\t\t\t} else {\n\t\t\t\tref = keyRef;\n\t\t\t}\n\n\t\t\tresult += cast(obj, false, ref).map(i => prepare(i, delimiter)).join(delimiter) + \"\\n\";\n\t\t}\n\n\t\treturn result.replace(REGEX_NL, \"\");\n\t}\n\n\tfunction coerce (value) {\n\t\tlet result, tmp;\n\n\t\tif (value === null || value === undefined) {\n\t\t\tresult = undefined;\n\t\t} else if (value === \"true\") {\n\t\t\tresult = true;\n\t\t} else if (value === \"false\") {\n\t\t\tresult = false;\n\t\t} else if (value === \"null\") {\n\t\t\tresult = null;\n\t\t} else if (value === \"undefined\") {\n\t\t\tresult = undefined;\n\t\t} else if (value === \"\") {\n\t\t\tresult = value;\n\t\t} else if (!isNaN(tmp = Number(value))) {\n\t\t\tresult = tmp;\n\t\t} else if (REGEX_JSON.test(value)) {\n\t\t\tresult = parse(value);\n\t\t} else {\n\t\t\tresult = value;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction decode (arg, delimiter = \",\") {\n\t\tconst regex = new RegExp(delimiter + \"(?=(?:[^\\\"]|\\\"(?:[^\\\"])[^\\\"]*\\\")*$)\"),\n\t\t\trows = trim(arg).split(\"\\n\"),\n\t\t\tkeyz = rows.shift().split(delimiter),\n\t\t\tresult = [],\n\t\t\tnth = rows.length,\n\t\t\tx = keyz.length;\n\n\t\tlet i = -1;\n\n\t\twhile (++i < nth) {\n\t\t\tlet obj = {},\n\t\t\t\trow = rows[i].split(regex),\n\t\t\t\tn = -1;\n\n\t\t\twhile (++n < x) {\n\t\t\t\tobj[keyz[n]] = coerce(row[n] || \"\");\n\t\t\t}\n\n\t\t\tresult.push(obj);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tconst iface = {\n\t\tdecode,\n\t\tencode,\n\t\tversion: \"2.0.1\"\n\t};\n\n\t// CommonJS, AMD, script tag\n\tif (typeof exports !== \"undefined\") {\n\t\tmodule.exports = iface;\n\t} else if (typeof define === \"function\" && typeof define.amd !== void 0) {\n\t\tdefine(() => iface);\n\t} else {\n\t\tglobal.csv = iface;\n\t}\n}(typeof window !== \"undefined\" ? window : global));\n"]}