{"version":3,"sources":["csv.js"],"names":["JSON","parse","Array","isArray","length","toString","test","includes","Object","indexOf","charAt","join","map","replace","isNaN","keys","Error","forEach","call","trim","from","push","decode","RegExp","split","shift","encode","version","exports","define","amd","csv","module","window","global"],"mappings":"AASC,YAAkB,CAmBlB,aAAqB,CACpB,GAAI,CACH,MAAOA,MAAKC,KAAL,GACP,CAAC,QAAU,CACX,QACA,CACD,CAmBD,eAAoC,CACnC,GAAI,EAAJ,CAsBA,MApBIC,OAAMC,OAAN,GAoBJ,CAnBsB,CAAjB,KAAMC,MAmBX,CAlBE,EAAS,EAkBX,EAhBE,EAAS,EAAMC,QAAN,EAgBX,CAdM,EAAcC,IAAd,GAcN,CAbG,EAAU,IAAG,MAAyB,GAazC,CAZa,EAAOC,QAAP,GAYb,GAXG,EAAU,IAAD,CAAW,GAWvB,GARW,YAAiBC,OAQ5B,CAPC,EAAU,IAAG,MAAyB,GAOvC,CAN4B,QAAjB,UAMX,CALC,EAAoC,CAAC,CAA5B,GAAMC,OAAN,KAAqD,IAApB,KAAMC,MAAN,CAAa,CAAb,CAAjC,CAA6D,IAAD,CAAU,GAAtE,EAKV,CAHC,GAGD,EACA,CAED,aAAsB,EAAY,GAAlC,CAAuC,IAAvC,GAA8D,CAC7D,KAAM,GAAM,IAAZ,CACA,GACC,EADD,CAAI,EAAS,EAAb,CA2BA,MAxBIR,OAAMC,OAAN,GAwBJ,CAvBkB,CAAb,GAAIC,MAuBT,GAtBM,EAAI,CAAJ,WAAkBI,OAsBxB,MApBI,EAAM,EAAK,EAAI,CAAJ,CAAL,CAoBV,CAnBI,EAAS,EAAIG,IAAJ,IAAsB,IAmBnC,EAhBG,GAAU,EAAIC,GAAJ,CAAQ,KAAK,WAAb,EAA+CD,IAA/C,CAAoD,IAApD,CAgBb,EAdG,GAAU,OAA0B,IAcvC,MATE,EAAM,MASR,CARE,EAAS,EAAIA,IAAJ,IAAsB,IAQjC,EANE,GAMF,CAHC,GAAU,UAAsBC,GAAtB,CAA0B,KAAK,MAA/B,EAAsDD,IAAtD,IAAwE,IAGnF,EAAO,EAAOE,OAAP,GAAyB,EAAzB,CACP,CAED,aAAwB,CACvB,GAAI,EAAJ,CAAY,CAAZ,CAsBA,SApBc,IAAV,MAAkB,UAoBtB,QAlBqB,MAAV,IAkBX,EAhBqB,OAAV,IAgBX,GAdqB,MAAV,IAcX,CAbU,IAaV,CAZqB,WAAV,IAYX,QAVqB,EAAV,IAUX,GARYC,MAAM,IAAN,CAQZ,CANW,EAAWR,IAAX,GAMX,CALU,IAKV,OACA,CA9HiB,KAGZ,GAAW,UAHC,CAIjB,EAAgB,mBAJC,CAKjB,EAAa,SALI,CAOZ,EAAO,OAAsB,IAAK,EAAb,KAAwCE,OAAOO,IAAP,GAAxC,CAAiB,EAAIH,GAAJ,CAAQ,KAAK,IAAb,CAP1B,CASZ,EAAU,SAAqB,CACpC,GAAkB,UAAd,UAAJ,CACC,KAAM,IAAII,MAAJ,CAAU,mBAAV,CAAN,CAKD,MAFA,CAAC,GAAUR,OAAOO,IAAP,GAAX,EAA6BE,OAA7B,CAAqC,KAAK,EAAGC,IAAH,GAAa,IAAb,GAA1C,CAEA,EACA,CAjBiB,CA2BZ,EAAO,KAAO,EAAIC,IAAJ,EA3BF,CA6BZ,EAAO,GAAM,IAAN,KAA2B,CACvC,GAAI,EAAJ,CAWA,MATIjB,OAAMC,OAAN,GASJ,CARC,EAASD,MAAMkB,IAAN,GAQV,GANC,EAAS,MAMV,EAJC,EAAS,EAIV,CAHC,IAAa,KAAK,EAAOC,IAAP,GAAlB,GAGD,GACA,CA1CiB,CAyJZ,EAAQ,CACbC,OA1BD,WAAsB,EAAY,GAAlC,CAAuC,CACtC,KAAM,GAAQ,GAAIC,OAAJ,CAAW,EAAY,qCAAvB,CAAd,CACC,EAAO,KAAUC,KAAV,CAAgB,IAAhB,CADR,CAEC,EAAO,EAAKC,KAAL,GAAaD,KAAb,GAFR,CAGC,EAAS,EAHV,CAIC,EAAM,EAAKpB,MAJZ,CAKC,EAAI,EAAKA,MALV,CADsC,IAQtC,GAAI,GAAI,CAAC,CAR6B,CAU/B,KAV+B,EAUpB,CACjB,GAAI,GAAM,EAAV,CACC,EAAM,KAAQoB,KAAR,GADP,CAEC,EAAI,CAAC,CAFN,CADiB,KAKV,KALU,EAMhB,EAAI,IAAJ,EAAe,EAAO,MAAU,EAAjB,CAAf,CAGD,EAAOH,IAAP,GACA,CAED,QACA,CAEa,CAEbK,QAFa,CAGbC,QAAS,OAHI,CAzJI,CAgKK,WAAnB,QAAOC,QAhKO,CAkKW,UAAlB,QAAOC,OAAP,EAAsD,IAAK,EAA3B,SAAOA,QAAOC,GAlKvC,CAmKjBD,OAAO,KAAP,CAnKiB,CAqKjB,EAAOE,GAAP,EArKiB,CAiKjBC,OAAOJ,OAAP,EAMD,CAvKA,EAuKmB,WAAlB,QAAOK,OAAP,CAAyCC,MAAzC,CAAgCD,MAvKjC,C","file":"unknown","sourcesContent":["/**\r\n * Simplify encoding & decoding CSV\r\n *\r\n * @author Jason Mulligan <jason.mulligan@avoidwork.com>\r\n * @copyright 2018\r\n * @license BSD-3-Clause\r\n * @link https://github.com/avoidwork/csv.js\r\n * @version 2.0.0\r\n */\r\n(function (global) {\r\n\t\r\n\r\n\tconst REGEX_NL = /(\\n|\\r)$/,\r\n\t\tREGEX_OBJTYPE = /\\[object Object\\]/,\r\n\t\tREGEX_JSON = /^[\\[\\{]/;\r\n\r\n\tconst keys = (obj, ref) => ref !== void 0 ? ref.map(i => obj[i]) : Object.keys(obj);\r\n\r\n\tconst iterate = (obj, fn, keyRef) => {\r\n\t\tif (typeof fn !== \"function\") {\r\n\t\t\tthrow new Error(\"Invalid arguments\");\r\n\t\t}\r\n\r\n\t\t(keyRef || Object.keys(obj)).forEach(i => fn.call(obj, obj[i], i));\r\n\r\n\t\treturn obj;\r\n\t};\r\n\r\n\tfunction parse (arg) {\r\n\t\ttry {\r\n\t\t\treturn JSON.parse(arg);\r\n\t\t} catch (e) {\r\n\t\t\treturn arg;\r\n\t\t}\r\n\t}\r\n\r\n\tconst trim = arg => arg.trim();\r\n\r\n\tconst cast = (obj, key = false, ref) => {\r\n\t\tlet result;\r\n\r\n\t\tif (Array.isArray(obj)) {\r\n\t\t\tresult = Array.from(obj);\r\n\t\t} else if (key) {\r\n\t\t\tresult = keys(obj, ref);\r\n\t\t} else {\r\n\t\t\tresult = [];\r\n\t\t\titerate(obj, i => result.push(i), ref);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t};\r\n\r\n\tfunction prepare (input, delimiter) {\r\n\t\tlet output;\r\n\r\n\t\tif (Array.isArray(input)) {\r\n\t\t\tif (input.length === 0) {\r\n\t\t\t\toutput = \"\";\r\n\t\t\t} else {\r\n\t\t\t\toutput = input.toString();\r\n\r\n\t\t\t\tif (REGEX_OBJTYPE.test(output)) {\r\n\t\t\t\t\toutput = `\"${encode(input, delimiter)}\"`; // eslint-disable-line no-use-before-define\r\n\t\t\t\t} else if (output.includes(delimiter)) {\r\n\t\t\t\t\toutput = `\"${output}\"`;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (input instanceof Object) {\r\n\t\t\toutput = `\"${encode(input, delimiter)}\"`; // eslint-disable-line no-use-before-define\r\n\t\t} else if (typeof input === \"string\") {\r\n\t\t\toutput = input.indexOf(delimiter) > -1 && input.charAt(0) !== \"\\\"\" ? `\"${input}\"` : input;\r\n\t\t} else {\r\n\t\t\toutput = input;\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\t}\r\n\r\n\tfunction encode (arg, delimiter = \",\", header = true, keyRef) {\r\n\t\tconst obj = parse(arg);\r\n\t\tlet result = \"\",\r\n\t\t\tref;\r\n\r\n\t\tif (Array.isArray(obj)) {\r\n\t\t\tif (obj.length > 0) {\r\n\t\t\t\tif (obj[0] instanceof Object) {\r\n\t\t\t\t\tif (header) {\r\n\t\t\t\t\t\tref = keys(obj[0]);\r\n\t\t\t\t\t\tresult = ref.join(delimiter) + \"\\n\";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresult += obj.map(i => encode(i, delimiter, false, ref)).join(\"\\n\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult += prepare(obj, delimiter) + \"\\n\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (header) {\r\n\t\t\t\tref = keys(obj, keyRef);\r\n\t\t\t\tresult = ref.join(delimiter) + \"\\n\";\r\n\t\t\t} else {\r\n\t\t\t\tref = keyRef;\r\n\t\t\t}\r\n\r\n\t\t\tresult += cast(obj, false, ref).map(i => prepare(i, delimiter)).join(delimiter) + \"\\n\";\r\n\t\t}\r\n\r\n\t\treturn result.replace(REGEX_NL, \"\");\r\n\t}\r\n\r\n\tfunction coerce (value) {\r\n\t\tlet result, tmp;\r\n\r\n\t\tif (value === null || value === undefined) {\r\n\t\t\tresult = undefined;\r\n\t\t} else if (value === \"true\") {\r\n\t\t\tresult = true;\r\n\t\t} else if (value === \"false\") {\r\n\t\t\tresult = false;\r\n\t\t} else if (value === \"null\") {\r\n\t\t\tresult = null;\r\n\t\t} else if (value === \"undefined\") {\r\n\t\t\tresult = undefined;\r\n\t\t} else if (value === \"\") {\r\n\t\t\tresult = value;\r\n\t\t} else if (!isNaN(tmp = Number(value))) {\r\n\t\t\tresult = tmp;\r\n\t\t} else if (REGEX_JSON.test(value)) {\r\n\t\t\tresult = parse(value);\r\n\t\t} else {\r\n\t\t\tresult = value;\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction decode (arg, delimiter = \",\") {\r\n\t\tconst regex = new RegExp(delimiter + \"(?=(?:[^\\\"]|\\\"(?:[^\\\"])[^\\\"]*\\\")*$)\"),\r\n\t\t\trows = trim(arg).split(\"\\n\"),\r\n\t\t\tkeyz = rows.shift().split(delimiter),\r\n\t\t\tresult = [],\r\n\t\t\tnth = rows.length,\r\n\t\t\tx = keyz.length;\r\n\r\n\t\tlet i = -1;\r\n\r\n\t\twhile (++i < nth) {\r\n\t\t\tlet obj = {},\r\n\t\t\t\trow = rows[i].split(regex),\r\n\t\t\t\tn = -1;\r\n\r\n\t\t\twhile (++n < x) {\r\n\t\t\t\tobj[keyz[n]] = coerce(row[n] || \"\");\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(obj);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tconst iface = {\r\n\t\tdecode,\r\n\t\tencode,\r\n\t\tversion: \"2.0.0\"\r\n\t};\r\n\r\n\t// CommonJS, AMD, script tag\r\n\tif (typeof exports !== \"undefined\") {\r\n\t\tmodule.exports = iface;\r\n\t} else if (typeof define === \"function\" && typeof define.amd !== void 0) {\r\n\t\tdefine(() => iface);\r\n\t} else {\r\n\t\tglobal.csv = iface;\r\n\t}\r\n}(typeof window !== \"undefined\" ? window : global));\r\n"]}